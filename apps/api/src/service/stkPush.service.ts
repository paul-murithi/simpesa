import { TransactionRepository } from "../../../../shared/db/repositories/transaction.repository.js";
import {
  TRANSACTION_STATUS,
  type TransactionStatus,
} from "../../../../shared/db/types/base-types.js";
import { TransactionUtils } from "../utils/transaction.utils.js";
import type { CreateTransactionDTO } from "../middleware/transaction.validation.js";
import { redisClient } from "../lib/redis/redisClient.js";
import { transactionQueries } from "../../../../shared/db/types/transaction.queries.js";
import { Query } from "../../../../shared/db/client.js";
import { randomUUID } from "crypto";
import { addPaymentJob } from "../../../../shared/queue/queue.js";

export class StkPushService {
  private utils = new TransactionUtils();
  private repo = new TransactionRepository();

  /**
   * Attempts to lock a fingerprint in Redis.
   * Returns true if successful (new), false if already exists (duplicate).
   */
  async tryLockTransaction(
    data: CreateTransactionDTO,
  ): Promise<null | { key: string; token: string }> {
    const hash = this.utils.generateRedisFingerprint(data);
    const key = `fp:${hash}`;
    const token = randomUUID();

    const result = await redisClient.set(key, token, {
      condition: "NX",
      expiration: { type: "EX", value: 60 },
    });

    if (result === null) {
      return null;
    }

    return { key, token };
  }

  /**
   * Deletes a Key from Redis in case of Transaction failure
   */
  async releaseLock(key: string, token: string): Promise<void> {
    await redisClient.eval(
      `
    if redis.call("GET", KEYS[1]) == ARGV[1] then
      return redis.call("DEL", KEYS[1])
    else
      return 0
    end
    `,
      {
        keys: [key],
        arguments: [token],
      },
    );
  }

  /**
   * Attempts to insert a new transaction into Postgres
   * @param dataDto - Cleaned data received from the user's request
   * @param checkoutId - UUID generated by the system
   * @param status - Transaction status set by the system
   */
  async insertTransaction(
    dataDto: CreateTransactionDTO,
    checkoutId: string,
    status: string,
  ) {
    const { amount, phone_number, short_code, external_reference } = dataDto;
    await this.repo.insertNewTransaction({
      amount: amount,
      checkoutId: checkoutId,
      externalReference: external_reference,
      phoneNumber: phone_number,
      shortCode: short_code,
      status: status,
    });
  }
  /**
   *Adds a new job to the queue for processing STK Push payment
   * @param data - Transaction request received from the user
   * @param checkOutId Unique UUID generated by the system
   */
  async queuePaymentTask(taskData: {
    checkoutId: string;
    phoneNumber: string;
    amount: number;
  }) {
    try {
      await addPaymentJob(taskData.checkoutId, taskData);
      console.log(`[Queue] Job queued for Checkout: ${taskData.checkoutId}`);
    } catch (error) {
      // This is where we catch "Redis is down"
      console.error("[Queue Error] Failed to hand off to BullMQ:", error);
      throw error; // Let the controller handle the cleanup
    }
  }
}
